# ![logo-valia-h64-v2](https://github.com/user-attachments/assets/ea937a53-9b80-43d7-93ac-81538d9526f8) ¬∑ [![npm version](https://img.shields.io/npm/v/valia.svg?style=flat)](https://www.npmjs.com/package/valia)

Biblioth√®que de validation l√©g√®re et moderne pour TypeScript et JavaScript.

üîå S‚Äôint√®gre naturellement √† vos projets, qu‚Äôils soient front-end ou back-end, et permet de d√©finir des sch√©mas de mani√®re intuitive tout en favorisant leur r√©utilisation.

üí° Pens√©e pour allier simplicit√© et puissance, elle propose des fonctionnalit√©s avanc√©es comme l‚Äôinf√©rence de types, ainsi que des validateurs standards tels que **isEmail**, **isUuid** ou **isIp**.

## Table des mati√®res

- [Schema](#schema)
  - [Instances](#instances)
  - [Formats](#formats)
  - [Exemples](#exemples)
- [Testers](#testers)
  - [Object](#object)
  - [String](#string-1)
- [Helpers](#helpers)
  - [Object](#object-1)
  - [String](#string-2)


## Installation

```
> npm install valia
```

```ts
import type { SchemaInfer } from 'valia';
import { Schema } from 'valia';

const user = new Schema({ 
  type: "object",
  shape: {
    name: { type: "string" },
    role: {
      type: "string",
      literal: ["WORKER", "CUSTOMER"]
    }
  }
});

type User = SchemaInfer<typeof user>;

let mock: User = {
  name: "Alice",
  role: "WORKER"
};

if (user.validate(mock)) {
  console.log(mock.name, mock.role);
}
```

<br/>

# Schema

## Instances

### Schema

`new Schema(criteria: SetableCriteria): Schema;`

<ul>
  <li>
    <strong>criteria</strong>
    <br/>
    Propri√©t√© repr√©sentant la racine des noeuds de crit√®res mont√©s.
  </li>
  <li>
    <strong>validate(data)</strong>
    <br/>
    Valide les donn√©es fournies selon le sch√©ma et retourne un bool√©en. Si elle renvoie <strong>true</strong>, TypeScript consid√®re que les donn√©es sont du type d√©fini par le sch√©ma.
    <br/>
    <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">En savoir plus sur la pr√©diction de types ‚Üó</a>
  </li>
  <li>
    <strong>evaluate(data)</strong>
    <br/>
    Valide les donn√©es fournies selon le sch√©ma et retourne un objet avec les propri√©t√©s suivantes :
    <ul>
      <li>
        <strong>rejection</strong>: Instance de <strong>SchemaDataRejection</strong> si les donn√©es sont rejet√©es sinon <strong>null</strong>.
      </li>
      <li>
        <strong>data</strong>: Donn√©es pass√©es en param√®tre de la fonction si celles-ci sont accept√©es sinon <strong>null</strong>.
      </li>
    </ul>
  </li>
</ul>

### SchemaException

<ul>
  <li>
    <strong>code</strong>
    <br/>
    Code de rejet (e.g. <strong>"REGEXP_"</strong>, <strong>"REGEX_UNSATISFIED"</strong>).
  </li>
  <li>
    <strong>message</strong>
    <br/>
    Message d√©fini sur le noeud ayant √©mis le rejet ou <strong>undefined</strong> si le message n'a pas √©t√© sp√©cifi√©.
  </li>
</ul>

### SchemaNodeException

<ul>
  <li>
    <strong>code</strong>
    <br/>
    Code de rejet du noeud de crit√®res (e.g. <strong>"MIN_PROPERTY_MALFORMED"</strong>, <strong>"REGEX_PROPERTY_MALFORMED"</strong>).
  </li>
  <li>
    <strong>label</strong>
    <br/>
    Label d√©fini sur le noeud de crit√®res ayant √©mis l'exception ou <strong>undefined</strong> si le label n'a pas √©t√© sp√©cifi√©.
  </li>
  <li>
    <strong>message</strong>
    <br/>
    Message d√©fini sur le noeud  de crit√®res ayant √©mis l'exception ou <strong>undefined</strong> si le message n'a pas √©t√© sp√©cifi√©.
  </li>
  <li>
    <strong>node</strong>
    <br/>
    Noeud de crit√®res ayant √©mis l'exception.
  </li>
  <li>
    <strong>nodePath</strong>
    <ul>
      <li>
        <strong>explicit</strong>: Tableau de segments repr√©sentant le chemin du noeud dans l'arbre des crit√®res du sch√©ma.
      </li>
      <li>
        <strong>implicit</strong>: Tableau de segments repr√©sentant le chemin du noeud dans l'arbre de donn√©es attendues par les crit√®res du schema.
      </li>
    </ul>
  </li>
</ul>

### SchemaDataRejection

<ul>
  <li>
    <strong>code</strong>
    <br/>
    Code de rejet du noeud (e.g. <strong>"MIN_UNSATISFIED"</strong>, <strong>"REGEX_UNSATISFIED"</strong>).
  </li>
  <li>
    <strong>label</strong>
    <br/>
    Label d√©fini sur le noeud ayant √©mis le rejet ou <strong>undefined</strong> si le label n'a pas √©t√© sp√©cifi√©.
  </li>
  <li>
    <strong>message</strong>
    <br/>
    Message d√©fini sur le noeud ayant √©mis le rejet ou <strong>undefined</strong> si le message n'a pas √©t√© sp√©cifi√©.
  </li>
  <li>
    <strong>node</strong>
    <br/>
    Noeud ayant √©mis le rejet.
  </li>
  <li>
    <strong>nodePath</strong>
    <ul>
      <li>
        <strong>explicit</strong>: Tableau de segments repr√©sentant le chemin du noeud dans l'arbre des crit√®res du sch√©ma.
      </li>
      <li>
        <strong>implicit</strong>: Tableau de segments repr√©sentant le chemin du noeud dans l'arbre de donn√©es attendues par les crit√®res du schema.
      </li>
    </ul>
  </li>
</ul>

## Formats

[Number](#number) ‚Ä¢ [String](#string) ‚Ä¢ [Boolean](#boolean) ‚Ä¢ [Object](#object) ‚Ä¢ [Array](#array) ‚Ä¢ [Function](#function) ‚Ä¢ [Symbol](#symbol) ‚Ä¢ [Simple](#simple) ‚Ä¢ [Union](#union)

Les formats d√©finissent les types de noeuds disponibles pour les crit√®res d'un sch√©ma.
<br/>
*L'ordre des propri√©t√©s d√©crites ici respecte l'ordre d'ex√©cution.*

### Global

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>label?</strong>
    <br/>
    Une chaine de carat√©res permetant d'idantifi√© le noeud, celle-ci vous sera retourn√©e dans les instance de <strong>SchemaDataRejection</strong> et <strong>SchemaNodeException</strong>.
  </li>
  <li>
    <strong>message?</strong>
    <br/>
    <ul>
      <li><strong>string</strong>: Cha√Æne de caract√®res qui vous sera retourn√©e dans les objets de r√©jection.</li>
      <li><strong>function</strong>: Fonction qui re√ßoit un objet de rejet en param√®tre et doit renvoyer une cha√Æne de caract√®res.</li>
    </ul>
  </li>
  <li>
    <strong>nullable?</strong>
    <br/>
    <ul>
      <li><strong>true</strong>: Peu importe le type utilis√© pour le noeud, la valeur sera autoris√©e √† √™tre <strong>null</strong>.</li>
      <li><strong>false</strong>: Peu importe le type utilis√© pour le noeud, la valeur ne sera pas autoris√©e √† √™tre <strong>null</strong>.</li>
    </ul>
  </li>
</ul>

### Number

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>min?</strong>
    <br/>
    Nombre minimale.
  </li>
  <li>
    <strong>max?</strong>
    <br/>
    Nombre maximale.
  </li>
  <li>
    <strong>literal?</strong>
    <br/>
    <ul>
      <li><strong>string</strong>: Restreint la valeur √† une seul nombre valide.</li>
      <li><strong>array</strong>: Restreint la valeur avec un tableau o√π les items repr√©sentent les nombres valides.</li>
      <li><strong>object</strong>: Restreint la valeur avec un objet o√π les valeurs repr√©sentent les nombres valides.</li>
    </ul>
  </li>
  <li>
    <strong>custom(value)?</strong>
    <br/>
    Fonction de validation custom qui re√ßoit la valeur en param√®tre et doit renvoyer un bool√©en indiquant si la celle-ci est valide.
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel nombre**
```ts
const schema = new Schema({
  type: "number"
});

‚úÖ schema.validate(0);
‚úÖ schema.validate(10);
‚úÖ schema.validate(-10);
```

**Valide des nombres qui appartiennent √† une plage sp√©cifique**
```ts
const schema = new Schema({
  type: "number",
  min: 0,
  max: 10
});

‚úÖ schema.validate(0);
‚úÖ schema.validate(10);

‚ùå schema.validate(-1);
‚ùå schema.validate(-10);
```

**Valid√© un nombre sp√©cifique**
```ts
const schema = new Schema({
  type: "number",
  literal: 141
});

‚úÖ schema.validate(141);

‚ùå schema.validate(-1);
‚ùå schema.validate(-10);
```

**Valid√© des nombres sp√©cifique avec un tableau**
```ts
const schema = new Schema({
  type: "number",
  literal: [141, 282]
});

‚úÖ schema.validate(141);
‚úÖ schema.validate(282);

‚ùå schema.validate(0);
‚ùå schema.validate(100);
‚ùå schema.validate(200);
```

### String

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>min?</strong>
    <br/>
    Longueur minimale de la cha√Æne de caract√®res.
  </li>
  <li>
    <strong>max?</strong>
    <br/>
    Longueur maximale de la cha√Æne de caract√®res.
  </li>
  <li>
    <strong>regex?</strong>
    <br/>
    Une expression r√©guli√®re fournie sous forme d'objet (<strong>RegExp</strong>).
  </li>
  <li>
    <strong>literal?</strong>
    <br/>
    <ul>
      <li><strong>string</strong>: Restreint la valeur √† une seul cha√Æne de caract√®res valides.</li>
      <li><strong>array</strong>: Restreint la valeur avec un tableau o√π les items repr√©sentent les cha√Æne de caract√®res valides.</li>
      <li><strong>object</strong>: Restreint la valeur avec un objet o√π les valeurs repr√©sentent les cha√Æne de caract√®res valides.</li>
    </ul>
  </li>
  <li>
    <strong>constraint?</strong>
    <br/>
    Un objet dont les cl√©s correspondent √† des noms de testeurs de cha√Æne et dont les valeurs possible sont :
    <ul>
      <li><strong>boolean</strong> : active ou d√©sactive le testeur.</li>
      <li><strong>objet</strong> : le testeur est activ√© avec les options sp√©cifi√©s dans l'objet.</li>
    </ul>
    La valeur sera consid√©r√©e comme valide si au moins un testeur renvoie un r√©sultat positif.
  </li>
  <li>
    <strong>custom(value)?</strong>
    <br/>
    Fonction de validation custom qui re√ßoit la valeur en param√®tre et doit renvoyer un bool√©en indiquant si la celle-ci est valide.
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel cha√Æne de caract√®res**
```ts
const schema = new Schema({
  type: "string"
});

‚úÖ schema.validate("");
‚úÖ schema.validate("abc");
```

**Valid√© des cha√Ænes de caract√®res ayant une longueur sp√©cifique**
```ts
const schema = new Schema({
  type: "string",
  min: 3,
  max: 3
});

‚úÖ schema.validate("abc");

‚ùå schema.validate("");
‚ùå schema.validate("a");
‚ùå schema.validate("abcd");
```

**Valid√© des cha√Ænes de caract√®res avec une expression r√©guli√®re**
```ts
const schema = new Schema({
  type: "string",
  regex: /^#[a-fA-F0-9]{6}$/
});

‚úÖ schema.validate("#000000");
‚úÖ schema.validate("#FFFFFF");

‚ùå schema.validate("");
‚ùå schema.validate("#000");
‚ùå schema.validate("#FFF");
```

**Valid√© une cha√Æne de caract√®res sp√©cifique**
```ts
const schema = new Schema({
  type: "string",
  literal: "ABC"
});

‚úÖ schema.validate("ABC");

‚ùå schema.validate("");
‚ùå schema.validate("a");
‚ùå schema.validate("abc");
```

**Valid√© des cha√Ænes de caract√®res sp√©cifique avec un tableau**
```ts
const schema = new Schema({
  type: "string",
  literal: ["ABC", "XYZ"]
});

‚úÖ schema.validate("ABC");
‚úÖ schema.validate("XYZ");

‚ùå schema.validate("");
‚ùå schema.validate("a");
‚ùå schema.validate("abc");
```

**Valid√© des cha√Ænes de caract√®res avec un testeur de cha√Æne**
```ts
const schema = new Schema({
  type: "string",
  constraint: {
    idIp: { cidr: true }
  }
});

‚úÖ schema.validate("127.0.0.1/24");

‚ùå schema.validate("");
‚ùå schema.validate("127.0.0.1");
```

**Valid√© des cha√Ænes de caract√®res avec plusieurs testeurs de cha√Æne**
```ts
const schema = new Schema({
  type: "string",
  constraint: {
    isEmail: true,
    idIp: { cidr: true }

  }
});

‚úÖ schema.validate("foo@bar");
‚úÖ schema.validate("127.0.0.1/24");

‚ùå schema.validate("");
‚ùå schema.validate("foo@");
‚ùå schema.validate("127.0.0.1");
```


### Boolean

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>literal?</strong>
    <br/>
    Restreint la valeur √† un seul √©tat de bool√©en valide.
  </li>
  <li>
    <strong>custom(value)?</strong>
    <br/>
    Fonction de validation custom qui re√ßoit la valeur en param√®tre et doit renvoyer un bool√©en indiquant si la celle-ci est valide.
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel bool√©en**
```ts
const schema = new Schema({
  type: "boolean"
});

‚úÖ schema.validate(true);
‚úÖ schema.validate(false);

‚ùå schema.validate("");
‚ùå schema.validate({});
```

**Valid√© un bool√©en avec un √©tat sp√©cifique**
```ts
const schema = new Schema({
  type: "boolean",
  literal: true
});

‚úÖ schema.validate(true);

‚ùå schema.validate("");
‚ùå schema.validate({});
‚ùå schema.validate(false);
```


### Object

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>nature?</strong> ‚Äî (Default: <strong>"STANDARD"</strong>)
    <ul>
      <li>
        <strong>"STANDARD"</strong>: Accepte toute valeur de type objet, c‚Äôest-√†-dire tout ce pour quoi <strong>typeof value === "object"</strong>.
      </li>
      <li>
        <strong>"PLAIN"</strong>: Accepte uniquement les objets dont le prototype est
        soit <strong>Object.prototype</strong> (comme les objets cr√©√©s via <strong>{}</strong>),
        soit <strong>null</strong> (cr√©√©s via <strong>Object.create(null)</strong>).
      </li>
    </ul>
  </li>
  <br/>
  <li>
    <strong>shape?</strong>
    <br/>
    Un objet dont les cl√©s sont de type <strong>string</strong> ou <strong>symbol</strong> et dont les valeurs sont des noeuds de crit√®res. Repr√©sente la forme d'une structure attendu.
  </li>
  <br/>
  <li>
    <strong>optional?</strong> ‚Äî (Default: <strong>false</strong> | Utilisable seulement si <strong>shape</strong> est d√©fini)
    <ul>
      <li>
        <strong>boolean</strong>
        <ul>
          <li><strong>true</strong>: Toutes les propri√©t√©s d√©finies dans l'objet <strong>shape</strong> sont optionnelles.</li>
          <li><strong>false</strong>: Toutes les propri√©t√©s d√©finies dans l'objet <strong>shape</strong> sont obligatoires.</li>
        </ul>
      </li>
      <li>
        <strong>array</strong>
        <br/>
        Un tableau dont les √©l√©ments repr√©sentes des cl√©s de l‚Äôobjet <strong>shape</strong> qui doivent √™tre consid√©r√©es comme optionnelles.
      </li>
    </ul>
  </li>
  <br/>
  <li>
    <strong>additional?</strong> ‚Äî (Default: <strong>false</strong> | Utilisable seulement si <strong>shape</strong> est d√©fini)
    <ul>
      <li>
        <strong>boolean</strong>
        <ul>
          <li><strong>true</strong>: Autorise la pr√©sence de propri√©t√©s additionnelles en plus de celles de l'objet <strong>shape</strong>.</li>
          <li><strong>false</strong>: N‚Äôautorise pas la pr√©sence de propri√©t√©s additionnelles en plus de celles de l'objet <strong>shape</strong>.</li>
        </ul>
      </li>
      <li>
        <strong>object</strong>
        <br/>
        <ul>
          <li><strong>min?</strong>: Nombre de propri√©t√©s additionnelles minimum.</li>
          <li><strong>max?</strong>: Nombre de propri√©t√©s additionnelles maximun.</li>
          <li><strong>key?</strong>: Noeud de crit√®res que les cl√©s additionnelles doivent satisfaire.</li>
          <li><strong>value?</strong>: Noeud de crit√®res que les valeurs additionnelles doivent satisfaire.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel objet standard**
```ts
const schema = new Schema({
  type: "object"
});

‚úÖ schema.validate({});
‚úÖ schema.validate([]);
‚úÖ schema.validate(new Date());
‚úÖ schema.validate(Object.create(null));

‚ùå schema.validate("");
```

**Valid√© un objet de nature simple**
```ts
const schema = new Schema({
  type: "object",
  nature: "PLAIN"
});

‚úÖ schema.validate({});
‚úÖ schema.validate(Object.create(null));

‚ùå schema.validate("");
‚ùå schema.validate([]);
‚ùå schema.validate(new Date());
```

**Valid√© un objet avec des propri√©t√©s fixes**
```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" }
  }
});

‚úÖ schema.validate({ foo: "x", bar: "x" });

‚ùå schema.validate({});
‚ùå schema.validate({ foo: "x" });
‚ùå schema.validate({ bar: "x" });
‚ùå schema.validate({ foo: "x", bar: "x", a: "" });
```

**Valid√© un objet et un sous-objet avec des propri√©t√©s fixes**
<br/>
*Il s'agit d'un raccourci qui convertira les sous-objets de **shape** en noeuds de crit√®res de type **object***.

```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" },
    baz: {
      foo: { type: "number" },
      bar: { type: "number" }
    }
  }
});

‚úÖ schema.validate({
  foo: "x",
  bar: "x",
  baz: {
    foo: 0,
    bar: 0
  }
});

‚ùå schema.validate({});
‚ùå schema.validate({ foo: "x" });
‚ùå schema.validate({ foo: "x", bar: "x" });
‚ùå schema.validate({ foo: "x", bar: "x", baz: {} });
‚ùå schema.validate({ foo: "x", bar: "x", baz: { foo: 0 } });
```

**Valid√© un objet avec des propri√©t√©s facultatives**
```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" }
  },
  optional: true
});

‚úÖ schema.validate({});
‚úÖ schema.validate({ foo: "x" });
‚úÖ schema.validate({ bar: "x" });
‚úÖ schema.validate({ foo: "x", bar: "x" });

‚ùå schema.validate({ foo: "x", bar: "x", a: "x" });
```

**Valid√© un objet avec une propri√©t√© fixe et une propri√©t√© facultative**
```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" }
  },
  optional: ["bar"]
});

‚úÖ schema.validate({ foo: "x" });
‚úÖ schema.validate({ foo: "x", bar: "x" });

‚ùå schema.validate({});
‚ùå schema.validate({ bar: "x" });
‚ùå schema.validate({ foo: "x", bar: "x", a: "x" });
```

**Valid√© un objet avec des propri√©t√©s fixes et autoris√© des propri√©t√©s additionnels**
```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" }
  },
  additional: true
});

‚úÖ schema.validate({ foo: "x", bar: "x" });
‚úÖ schema.validate({ foo: "x", bar: "x", a: "x", b: 0 });

‚ùå schema.validate({});
‚ùå schema.validate({ bar: "x" });
‚ùå schema.validate({ foo: "x" });
```

**Valid√© un objet avec des propri√©t√©s fixes et autoris√© des propri√©t√©s additionnels qui respecte des noeuds de crit√®res**
```ts
const schema = new Schema({
  type: "object",
  shape: {
    foo: { type: "string" },
    bar: { type: "string" }
  },
  additional: {
    key: { type: "string" },
    value: { type: "number" }
  }
});

‚úÖ schema.validate({ foo: "x", bar: "x" });
‚úÖ schema.validate({ foo: "x", bar: "x", a: 0 });
‚úÖ schema.validate({ foo: "x", bar: "x", a: 0, b: 0 });

‚ùå schema.validate({});
‚ùå schema.validate({ foo: "x" });
‚ùå schema.validate({ bar: "x" });
‚ùå schema.validate({ foo: "x", bar: "x", a: "x", b: 0 });
```

### Array

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>shape?</strong>
    <br/>
    Un tableau dont les √©l√©ments sont des noeuds de crit√®res. Repr√©sente la forme d‚Äôun uplet attendu.
  </li>
  <br/>
  <li>
    <strong>additional?</strong> ‚Äî (Default: <strong>false</strong> | Utilisable seulement si <strong>shape</strong> est d√©fini)
    <ul>
      <li>
        <strong>boolean</strong>
        <ul>
          <li><strong>true</strong>: Autorise la pr√©sence d‚Äô√©l√©ments additionnelles √† la suite de <strong>shape</strong>.</li>
          <li><strong>false</strong>: N‚Äôautorise pas la pr√©sence d‚Äô√©l√©ments additionnelles √† la suite de <strong>shape</strong>.</li>
        </ul>
      </li>
      <li>
        <strong>object</strong>
        <br/>
        <ul>
          <li><strong>min?</strong>: Nombre d'√©l√©ments additionnelles minimum.</li>
          <li><strong>max?</strong>: Nombre d'√©l√©ments additionnelles maximun.</li>
          <li><strong>item?</strong>: Noeud de crit√®res que les √©l√©ments additionnelles doivent satisfaire.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel tableau standard**
```ts
const schema = new Schema({
  type: "array"
});

‚úÖ schema.validate([]);
‚úÖ schema.validate(["x"]);

‚ùå schema.validate({});
‚ùå schema.validate("x");
```

**Valid√© un tableau d'√©l√©ments fixes**
```ts
const schema = new Schema({
  type: "array",
  shape: [
    { type: "string" },
    { type: "string" }
  ]
});

‚úÖ schema.validate(["x", "x"]);

‚ùå schema.validate([]);
‚ùå schema.validate(["x"]);
‚ùå schema.validate(["x", "x", "x"]);
```

**Valid√© un tableau et un sous-tableau d'√©l√©ments fixes**
<br/>
*Il s'agit d'un raccourci qui convertira les sous-tableaux de **shape** en noeuds de crit√®res de type **array***.

```ts
const schema = new Schema({
  type: "array",
  shape: [
    { type: "string" },
    { type: "string" },
    [
      { type: "number" },
      { type: "number" }
    ]
  ]
});

‚úÖ schema.validate(["x", "x", [0, 0]]);

‚ùå schema.validate([]);
‚ùå schema.validate(["x"]);
‚ùå schema.validate(["x", "x", []]);
‚ùå schema.validate(["x", "x", [0]]);
```

**Valid√© un tableau d'√©l√©ments fixes et autoris√© des √©l√©ments additionnels**
```ts
const schema = new Schema({
  type: "array",
  shape: [
    { type: "string" },
    { type: "string" }
  ],
  additional: true
});

‚úÖ schema.validate(["x", "x"]);
‚úÖ schema.validate(["x", "x", "x"]);
‚úÖ schema.validate(["x", "x", "x", 0]);

‚ùå schema.validate([]);
‚ùå schema.validate(["x"]);
```

**Valid√© un tableau d'√©l√©ments fixes et autoris√© des √©l√©ments additionnels qui respecte un noeud de crit√®res**
```ts
const schema = new Schema({
  type: "array",
  shape: [
    { type: "string" },
    { type: "string" }
  ],
  additional: {
    item: { type: "number" }
  }
});

‚úÖ schema.validate(["x", "x"]);
‚úÖ schema.validate(["x", "x", 0]);
‚úÖ schema.validate(["x", "x", 0, 0]);

‚ùå schema.validate([]);
‚ùå schema.validate(["x"]);
‚ùå schema.validate(["x", "x", "x"]);
```


### Symbol

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>literal?</strong>
    <br/>
    <ul>
      <li><strong>symbol</strong>: Restreint la valeur √† un seul symbole valide.</li>
      <li><strong>array</strong>: Restreint la valeur avec un tableau o√π les items repr√©sentent les symboles valides.</li>
      <li><strong>object</strong>: Restreint la valeur avec un objet o√π les valeurs repr√©sentent les symboles valides.</li>
    </ul>
  </li>
  <br/>
  <li>
    <strong>custom(value)?</strong>
    <br/>
    Fonction de validation custom qui re√ßoit la valeur en param√®tre et doit renvoyer un bool√©en indiquant si la celle-ci est valide.
  </li>
</ul>

#### **Exemples :**

**Valid√© n'importe quel symbole**
```ts
const xSymbol = Symbol("x");
const ySymbol = Symbol("y");

const schema = new Schema({
  type: "symbol"
});

‚úÖ schema.validate(xSymbol);
‚úÖ schema.validate(ySymbol);
```

**Valid√© un symbole sp√©cifique**
```ts
const xSymbol = Symbol("x");
const ySymbol = Symbol("y");

const schema = new Schema({
  type: "symbol",
  literal: xSymbol
});

‚úÖ schema.validate(xSymbol);

‚ùå schema.validate(ySymbol);
```

**Valid√© des symboles sp√©cifiques avec un tableau**
```ts
const xSymbol = Symbol("x");
const ySymbol = Symbol("y");
const zSymbol = Symbol("z");

const schema = new Schema({
  type: "symbol",
  literal: [xSymbol, ySymbol]
});

‚úÖ schema.validate(xSymbol);
‚úÖ schema.validate(ySymbol);

‚ùå schema.validate(zSymbol);
```

**Valid√© des symboles sp√©cifiques avec un enum**
```ts
enum mySymbol {
  X = Symbol("x"),
  Y = Symbol("y"),
};

enum otherSymbol {
  Z = Symbol("z")
};

const schema = new Schema({
  type: "symbol",
  literal: mySymbol
});

‚úÖ schema.validate(mySymbol.X);
‚úÖ schema.validate(mySymbol.Y);

‚ùå schema.validate(otherSymbol.Z);
```


### Simple

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>simple</strong>
    <br/>
     <ul>
      <li><strong>"NULL"</strong>: La valeur doit √™tre √©gale √† <strong>null</strong>.</li>
      <li><strong>"UNDEFINED"</strong>: La valeur doit √™tre √©gale √† <strong>undefined</strong>.</li>
      <li><strong>"NULLISH"</strong>: La valeur doit √™tre √©gale √† <strong>null</strong> ou <strong>undefined</strong>.</li>
      <li><strong>"UNKNOWN"</strong>: Toute valeur est accept√©e sans aucune contrainte.</li>
    </ul>
  </li>
</ul>

#### **Exemples :**

```ts
const schema = new Schema({
  type: "simple",
  simple: "NULL"
});

‚úÖ schema.validate(null);

‚ùå schema.validate(0);
‚ùå schema.validate("");
‚ùå schema.validate({});
```

### Union

#### **Propri√©t√©s :**

<ul>
  <li>
    <strong>union</strong>
    <br/>
    Un tableau de noeuds de crit√®res, o√π chaque noeud d√©finit une valeur acceptable.<br/>
    Une valeur est consid√©r√©e comme valide si elle correspond √† au moins un des noeuds de crit√®res fournis.
  </li>
</ul>

#### **Exemples :**

```ts
const schema = new Schema({
  type: "union",
  union: [
    { type: "string" },
    { type: "number" }
  ]
});

‚úÖ schema.validate(0);
‚úÖ schema.validate("");

‚ùå schema.validate({});
```

## Exemples

### Sch√©ma simple

```ts
const user = new Schema({ 
  type: "object",
  shape: {
    name: {
      type: "string",
      min: 3,
      max: 32
    },
    role: {
      type: "string",
      literal: ["WORKER", "CUSTOMER"]
    }
  }
});

‚úÖ user.validate({
  name: "Alice",
  role: "WORKER"
});

‚ùå user.validate({
  name: "Alice",
  role: "MANAGER"
});
```

### Sch√©ma composite

```ts
const name = new Schema({
  type: "string",
  min: 3,
  max: 32
});

const role = new Schema({
  type: "string",
  literal: ["WORKER", "CUSTOMER"]
});

const user = new Schema({ 
  type: "object",
  shape: {
    name: name.criteria,
    role: role.criteria
  }
});

‚úÖ user.validate({
  name: "Bob",
  role: "CUSTOMER"
});

‚ùå user.validate({
  name: "Bob",
  role: "MANAGER"
});
```

### Sch√©ma composite profond

```ts
const name = new Schema({
  type: "string",
  min: 3,
  max: 32
});

const setting = new Schema({
  type: "object",
  shape: {
    theme: {
      type: "string",
      literal: ["DARK", "LIGHT"]
    },
    notification: { type: "boolean" }
  }
});

const user = new Schema({ 
  type: "object",
  object: {
    name: name.criteria,
    theme: setting.criteria.shape.theme
  }
});

‚úÖ user.validate({
  name: "Alice",
  theme: "DARK"
});

‚ùå user.validate({
  name: "Alice",
  theme: "DEFAULT"
});
```

<br/><br/>

# Testers

## Object

#### `isObject(value): boolean`
V√©rifie si la valeur fournie est de type **object**.

#### `isPlainObject(value): boolean`
V√©rifie si la valeur fournie est de type **object** et dont le prototype est soit **Object.prototype**, soit **null**.
<br/>Par exemple les valeurs cr√©√©es via le litt√©rale **{}** ou via **Object.create(null)** font partie des valeurs accept√©es.

#### `isArray(value): boolean`
V√©rifie si la valeur fournie est de type **array**.

#### `isTypedArray(value): boolean`
V√©rifie si la valeur fournie est de type **array** et si elle est une vue sur un **ArrayBuffer**, √† l‚Äôexception des **DataView**.

#### `isFunction(value): boolean`
V√©rifie si la valeur fournie est de type **function**.

#### `isBasicFunction(value): boolean`
V√©rifie si la valeur fournie est de type **function** et qu'elle n'est pas de nature **async**, **generator** ou **async generator**.

#### `isAsyncFunction(value): boolean`
V√©rifie si la valeur fournie est de type **function** et qu'elle n'est pas de nature **basic**, **generator** ou **async generator**.

#### `isGeneratorFunction(value): boolean`
V√©rifie si la valeur fournie est de type **function** et qu'elle n'est pas de nature **basic**, **async** ou **async generator**.

#### `isAsyncGeneratorFunction(value): boolean`
V√©rifie si la valeur fournie est de type **function** et qu'elle n'est pas de nature **basic**, **async** ou **generator**.

<br/>

## String

#### `isAscii(str): boolean`
V√©rifie si la cha√Æne fournie n'est compos√©e que de caract√®res ASCII.‚ÄØ

#### `isIpV4(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† une IPV4.

#### `isIpV6(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† une IPV6.

#### `isIp(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† une IPV4 ou une IPV6.

**Options:**
<ul>
  <li>
    <strong>cidr?</strong> ‚Äî (Default: <strong>false</strong>)
    <br/>
    Si <strong>true</strong>, rend obligatoire la pr√©sence d'un suffixe CIDR, sinon si <strong>false</strong> un suffixe n'est pas accept√©.
  </li>
</ul>

#### `isEmail(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† une adresse email.

**Options:**
<ul>
  <li>
    <strong>allowLocalQuotes?: boolean</strong> ‚Äî (Default: <strong>false</strong>)
    <br/>
    Sp√©cifie si la premi√®re partie (partie locale) de l'adresse email peut √™tre form√©e √† l'aide de guillemets. Par exemple, <strong>"Jean Dupont"@exemple.com</strong> sera consid√©r√© comme valide.
  </li>
  <li>
    <strong>allowIpAddress?: boolean</strong> ‚Äî (Default: <strong>false</strong>)
    <br/>
    Sp√©cifie si la deuxi√®me partie (partie domain) de l'adresse email peut √™tre une adresse IP. Par exemple, <strong>foo@8.8.8.8</strong> sera consid√©r√© comme valide.
  </li>
  <li>
    <strong>allowGeneralAddress?: boolean</strong> ‚Äî (Default: <strong>false</strong>)
    <br/>
    Sp√©cifie si la deuxi√®me partie (partie domain) de l'adresse email peut √™tre une adresse general. Par exemple, <strong>foo@8.8.8.8</strong> sera consid√©r√© comme valide.
  </li>
</ul>

**Standards:** RFC 5321

#### `isDomain(str): boolean`
V√©rifie si la cha√Æne fournie correspond un nom de domain.

**Standards:** RFC 1035

#### `isDataURL(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† une **DataURL**.

**Options:**
<ul>
  <li>
    <strong>type?: string[]</strong>
    <br/>
    Sp√©cifie un ou plusieurs types MIME autoris√©s.
    <br/>
    <a href="http://www.iana.org/assignments/media-types/">Liste des types MIME enregistr√©s par l'IANA ‚Üó</a>
  </li>
  <li>
    <strong>subtype?: string[]</strong>
    <br/>
    Sp√©cifie un ou plusieurs sous-types MIME autoris√©s.
    <br/>
    <a href="http://www.iana.org/assignments/media-types/">Liste des types MIME enregistr√©s par l'IANA ‚Üó</a>
  </li>
</ul>

**Standards:** RFC 2397

#### `isUuid(str [, options]): boolean`
V√©rifie si la cha√Æne fournie correspond √† un **UUID** valide.

**Options:**
<ul>
  <li>
    <strong>version?: number</strong>
    <br/>
    Sp√©cifie le num√©ro de version autoris√©, compris entre 1 et 7.
  </li>
</ul>

**Standards:** RFC 9562

#### `isBase16(str): boolean`
V√©rifie si la cha√Æne fournie correspond √† un encodage **base16** valide.

**Standards:** RFC 4648

#### `isBase32(str): boolean`
V√©rifie si la cha√Æne fournie correspond √† un encodage **base32** valide.

**Standards:** RFC 4648

#### `isBase32Hex(str): boolean`
V√©rifie si la cha√Æne fournie correspond √† un encodage **base32Hex** valide.

**Standards:** RFC 4648

#### `isBase64(str): boolean`
V√©rifie si la cha√Æne fournie correspond √† un encodage **base64** valide.

**Standards:** RFC 4648

#### `isBase64Url(str): boolean`
V√©rifie si la cha√Æne fournie correspond √† un encodage **base64Url** valide.

**Standards:** RFC 4648

<br/><br/>

# Helpers

## Object

#### `getInternalTag(target): string`
Retourne le tag interne de la cible. Par exemple pour une cible **async () => {}** le tag retourn√© est **"AsyncFunction"**.

<br/>

## String

#### `base16ToBase32(str [, to, padding]): string`
Convertie une cha√Æne en **base16** en une cha√Æne en **base32** ou **base32Hex**.

**Arguments:**
<ul>
  <li>
    <strong>to?: "B32" | "B32HEX"</strong> ‚Äî (Default: <strong>"B32"</strong>)
    <br/>
    Sp√©cifie dans quel encodage la cha√Æne doit √™tre convertie.
  </li>
  <br/>
  <li>
    <strong>padding?: boolean</strong> ‚Äî (Default: <strong>true</strong>)
    <br/>
    Sp√©cifie si la cha√Æne doit √™tre compl√©t√©e par un remplissage si n√©cessaire.
  </li>
</ul>

**Standards:** RFC 4648

#### `base16ToBase64(str [, to, padding]): string`
Convertie une cha√Æne en **base16** en une cha√Æne en **base64** ou **base64Url**.

**Arguments:**
<ul>
  <li>
    <strong>to?: "B64" | "B64URL"</strong> ‚Äî (Default: <strong>"B64"</strong>)
    <br/>
    Sp√©cifie dans quel encodage la cha√Æne doit √™tre convertie.
  </li>
  <br/>
  <li>
    <strong>padding?: boolean</strong> ‚Äî (Default: <strong>true</strong>)
    <br/>
    Sp√©cifie si la cha√Æne doit √™tre compl√©t√©e par un remplissage si n√©cessaire.
  </li>
</ul>

**Standards:** RFC 4648

#### `base32ToBase16(str [, from]): string`
Convertie une cha√Æne en **base32** ou **base32Hex** en une cha√Æne en **base16**.

**Arguments:**
<ul>
  <li>
    <strong>from?: "B32" | "B32HEX"</strong> ‚Äî (Default: <strong>"B32"</strong>)
    <br/>
    Sp√©cifie dans quel encodage la cha√Æne doit √™tre fournie.
  </li>
</ul>

**Standards:** RFC 4648

#### `base64ToBase16(str [, from]): string`
Convertie une cha√Æne en **base64** ou **base64Url** en une cha√Æne en **base16**.

**Arguments:**
<ul>
  <li>
    <strong>from?: "B64" | "B64URL"</strong> ‚Äî (Default: <strong>"B64"</strong>)
    <br/>
    Sp√©cifie dans quel encodage la cha√Æne doit √™tre fournie.
  </li>
</ul>